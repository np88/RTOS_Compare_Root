\chapter{Einleitung}
\section{Realzeitbetriebssysteme}
	\begin{itemize}
		\item Was sind RTOS und was macht sie aus?
		\item Warum verwendet man sie anstatt herkömmlicher Betriebssysteme oder dedizierter Hardware?
		\item Verschiedene Arten von RTOS und ihre Vor-/Nachteile (Wofür eignen sich bestimmte Systeme besonders gut, grober Überblick über vorhandenes)
		\item Beschreiben der Zielhardware/Randbedingungen
		\item Auskristallisieren, warum in der Arbeit gerade Linux RT Patch und FreeRTOS verwendet werden (evtl noch andere, z.B. MicroCOS, Xenomai)	
	\end{itemize}
	
\section{Welche Eigenschaften werden verglichen?}
\section{Relevante Betriebssysteme}
\subsection{Linux}
\subsubsection{Prozesse}
Prozesse in Linux sind als doppelt verkettet Liste implementiert. Die Prozesse im State \textit{Running} haben eine Liste pro Priorität. Prozesse in States wie \textit{Task\_Stopped}, \textit{Exit\_Zombie} oder \textit{Exit\_Dead} werden nicht in speziellen Listen gespeichert, weil der Zugriff meistens über PID oder Kind Prozesse stattfindet. Tasks, die interruptable oder nicht interruptable sind, müssen feiner gruppiert werden, um den Anforderungen der entsprechenden Funktionalität zu genügen. Zum Beispiel werden wartende (schlafende) Prozesse in einer Waiting Queue eingereiht. Je nach dem, ob ein Ereignis eintrifft, oder eine Ressource frei wird, werden entsprechende Prozesse wieder aufgeweckt. Context Switches werden nur im Kernel Modus vollzogen. Der Switch wird über Software gesteuert, nicht über Hardware. 
\subsubsection{Scheduling Policy}
The scheduler stores the records about the planned tasks in a red-black tree, using the spent processor time as a key. This allows it to pick efficiently the process that has used the least amount of time (it is stored in the leftmost node of the tree). The entry of the picked process is then removed from the tree, the spent execution time is updated and the entry is then returned to the tree where it normally takes some other location. The new leftmost node is then picked from the tree, repeating the iteration.\\\\
If the task spends a lot of its time sleeping, then its spent time value is low and it automatically gets the priority boost when it finally needs it. Hence such tasks do not get less processor time than the tasks that are constantly running.

\subsubsection{Interrupts}
Regardless of the kind of circuit that caused the interrupt, all I/O interrupt handlers perform the
same four basic actions:
\begin{enumerate}
	\item Save the IRQ value and the register's contents on the Kernel Mode stack.
	\item Send an acknowledgment to the PIC that is servicing the IRQ line, thus allowing it to issue further interrupts.
	\item Execute the interrupt service routines (ISRs) associated with all the devices that share
the IRQ.
	\item Terminate by jumping to the \textit{ret\_from\_intr} address.
\end{enumerate}

\subsection{RT Linux}
Um Linux RT fähiger zu machen, werden IRQs anders behandelt als im normalen Linux. Im normalen Linux unterbrechen sie einfach den laufenden Betrieb des Betriebssystems. Mit dem RT-Patch werden die ISRs in eigene Prozesse mit Prioritäten umgewandelt, sodass RT-Prozesse eine höhere Priorität haben können als IRQs und damit weniger anfällig für Unterbrechungen sind. IRQs werden im RT-Patch mit der FIFO\_SCHED Policy geschedulet und haben eine Priorität von 50.
\\\\In PREEMPT_RT, normal spinlocks (spinlock_t and rwlock_t) are preemptible, as are RCU read-side critical sections. Es gibt aber eine zusätzliche Art von Spin Locks, die das traditionelle Verhalten erlaubt.

\subsection{FreeRTOS}
	\begin{itemize}
		\item Tasks können die gleiche Priorität haben
		\item Tick rate bestimmt Zeitauflösung $ \rightarrow $ je öfter es aufgerufen wird, desto mehr Zeit wird für das Betriebssystem aufgewendet (Task switches werden dann ausgeführt)
		\item Normalerweise sollten ISR so kurz wie möglich sein. Deswegen wird ein hoch priorisierter Task aus der ISR aufgerufen, der eine Priorität größer oder gleich dem System-Interrupt hat und wird dadurch nicht durch das System unterbrochen
		\item A mutex, recursive mutex, binary semaphore and a counting semaphore is using the existing queue mechanism.
		\item Mutexes include priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.  
		\item Rekursiver Mutex: Ein Mutex kann mehrfach gelockt werden, muss aber auch mehrfach wieder entlockt werden.
	\end{itemize}

