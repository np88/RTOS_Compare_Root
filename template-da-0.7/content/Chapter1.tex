\chapter{Benchmarking}
Vergleichskriterien für Betriebssysteme
\begin{itemize}
	\item Performanz
	\item Sicherheit
	\item Ressourcen-/Speicherverbrauch
	\item Speicherverwaltung
\end{itemize}

\section{Performanz}
\begin{enumerate}
	\item Latenzzeiten/Jitter
		\begin{enumerate}
			\item Interrupt durch Taster $ \rightarrow $ Aufblinken von LED (die Zeit, die dasAufblinken benötigt, kann gemessen und abgezogen werden, so dass nur die Zeit vom Drücken des Tasters bis zum Ausführen der ISR bleibt)
			\item Andere Interruptquellen? ( $ \rightarrow $ z.B CAN, Ethernet, SPI, ...)
			\item Verschiedene Taktzeiten von FreeRTOS
		\end{enumerate}
	\item Durchsatz an Daten
		\begin{enumerate}
			\item Ethernet
			\item CAN
			\item SPI
		\end{enumerate}	
	\item Bootzeit
		\begin{enumerate}
			\item Was hat Einwirkungen auf die Bootzeit?
			\item Indikatoren $ \rightarrow $ Wann ist das System hochgefahren?
			\item Bestimmtes Programm wird gestartet $ \rightarrow $ z.B. Aufleuchten von LED
			\item Bestimmte Programme können den Bootvorgang aufzeichen (Bootchart)  
		\end{enumerate}			
	\item Scheduling/Context-Switching
		\begin{enumerate}
			\item Hardware-Timer $ \rightarrow $ genauer als Software-Timer 
			\item In FreeRTOS: Axi-Timer, der im PL instanziert wird
			\item In Linux: clock\_gettime() mit CLOCK\_MONOTONIC (braucht keinen Treiber für Axi-Timer und Zugriffszeit auf Hardware fällt weg)
			\item Beispiel: Start Task1 and Timer $ \rightarrow $ Sleep Task1 $ \rightarrow $ WakeUp Task2 $ \rightarrow $ Timer stop
			\item SPI
		\end{enumerate}			
\end{enumerate}

\subsection{Latenzzeiten von Interrupts}
Für die Latenzzeit von Interrupts soll ein Interrupt von einer externen Quelle ausgelöst werden und dann wird gemessen, wann die Interruptserviceroutine betreten wird. Konkret wird periodisch ein GPIO-Interrupt durch einen Signalgenerator in Hardware ausgelöst. Die GPIO wird über das EMIO-Interface angebunden. In der dazugehörigen ISR wird eine LED angeschaltet. Es wird die Zeit zwischen dem Setzen des Interruptsignals und aufblinken der LED gemessen. Von dieser Zeit muss abgezogen werden, wie lange das Anschalten der LED und die Zeitmessung an sich dauert. Grundsätzlich wird jede Messung 1024 Mal durchgeführt. Für die Zusatzmessungen sind die Durchschnittszeiten interessant. Für die Hauptmessung ist zusätzlich der Worst-Case-Fall zu beachten.
 
\subsubsection{FreeRTOS}
Bei FreeRTOS werden die Interrupts unabhängig vom Betriebssystem verwaltet. Der EMIO-GPIO-Interrupt hat nach dem System-Timer die höchste Priorität. 
\\\\Axi-Timer: 50 MHz

Ergebnis: 

\begin{table*}[htb]
	\centering
		\begin{tabular}{|l|l|}
			\hline
			 Anz. Messungen &  19100 \\	
			\hline
			 Durchschnittswert & 754,8ns \\
			\hline
			 Standardabweichung &  8,5977ns (19.31 ns) \\
			\hline
			 Minimalwert & 740ns \\
			\hline	
			 Maximalwert &  780ns \\
			\hline
			 Durchschnittswert LED-Anschalten &  700-740ns (130 ns)\\
			\hline
			 Durchschnittswert Timer-Overhead &  520ns (9ns) \\
			\hline				
			LED-Overhead bei ISR-Messung & 220ns (121 ns)\\
			\hline		
			Durchschnitt - Overhead & 633,8ns \\
			\hline	
			Durchschnitt - Overhead (Taktzyklen) & 422 Zyklen\\
			\hline								
		\end{tabular}
		\label{theap1}
\end{table*}

mit Task:
\begin{table*}[htb]
	\centering
		\begin{tabular}{|l|l|}
			\hline
			 Anz. Messungen &  19100 \\	
			\hline
			 Durchschnittswert & 754,8ns \\
			\hline
			 Standardabweichung &  8,5977ns (19.31 ns) \\
			\hline
			 Minimalwert & 719ns \\
			\hline	
			 Maximalwert & 840ns \\
			\hline
			 Durchschnittswert LED-Anschalten &  700-740ns (130 ns)\\
			\hline
			 Durchschnittswert Timer-Overhead &  520ns (9ns) \\
			\hline				
			LED-Overhead bei ISR-Messung & 220ns (121 ns)\\
			\hline		
			Durchschnitt - Overhead & 633,8ns \\
			\hline	
			Durchschnitt - Overhead (Taktzyklen) & 422 Zyklen\\
			\hline								
		\end{tabular}
		\label{theap1}
\end{table*}

\subsubsection{LinuxRT}
Messung mit wmb():
Ergebnis: 
\begin{table*}[htb]
	\centering
		\begin{tabular}{|l|l|}
			\hline
			 Anz. Messungen &  19160 \\	
			\hline
			 Durchschnittswert & 13,569us \\
			\hline
			 Standardabweichung &  1,4412us \\
			\hline
			 Minimalwert & 8us \\
			\hline	
			 Maximalwert &  28,8us \\
			\hline
			 Durchschnittswert LED-Anschalten &   \\
			\hline
			 Durchschnittswert Timer-Overhead &   \\
			\hline				
			LED-Overhead bei ISR-Messung &  \\
			\hline		
			Durchschnitt - Overhead & s \\
			\hline	
			Durchschnitt - Overhead (Taktzyklen) & \\
			\hline								
		\end{tabular}
		\label{theap1}
\end{table*}

Messung ohne wmb():
Ergebnis: 
\begin{table*}[htb]
	\centering
		\begin{tabular}{|l|l|}
			\hline
			 Anz. Messungen &  19130 \\	
			\hline
			 Durchschnittswert & 13,406us \\
			\hline
			 Standardabweichung &  1,3419us \\
			\hline
			 Minimalwert & 8,6us \\
			\hline	
			 Maximalwert &  32us \\
			\hline
			 Durchschnittswert LED-Anschalten &   \\
			\hline
			 Durchschnittswert Timer-Overhead &   \\
			\hline				
			LED-Overhead bei ISR-Messung &  \\
			\hline		
			Durchschnitt - Overhead & s \\
			\hline	
			Durchschnitt - Overhead (Taktzyklen) & \\
			\hline								
		\end{tabular}
		\label{theap1}
\end{table*}

Messung For-Loops in Zyklen:
\begin{table*}[htb]
	\centering
		\begin{tabular}{|l|l|l|}
			\hline	
			For-Loop 0 & Runden 16 &  180  \\
			\hline	
			For-Loop 1 & Runden 32 &  304  \\
			\hline	
			For-Loop 2 & Runden 64 &  533 \\
			\hline	
			For-Loop 3 & Runden 128 &  1045  \\
			\hline	
			For-Loop 4 & Runden 264 &  2133  \\
			\hline	
			For-Loop 5 & Runden 512 &  4117  \\
			\hline	
			For-Loop 6 & Runden 1024 &  8213  \\
			\hline	
			For-Loop 7 & Runden 2048 &  16405  \\
			\hline	
			For-Loop 8 & Runden 4096 &  32789  \\
			\hline	
			For-Loop 9 & Runden 8192 & 65557  \\
			\hline	
		\end{tabular}
		\label{theap1}
\end{table*}

Messung While-Loops in Zyklen:
\begin{table*}[htb]
	\centering
		\begin{tabular}{|l|l|l|}
			\hline	
			Loop 0 & Runden 16 &  171  \\
			\hline	
			Loop 1 & Runden 32 & 301 \\
			\hline	
			Loop 2 & Runden 64 &  535 \\
			\hline	
			Loop 3 & Runden 128 &  1047  \\
			\hline	
			Loop 4 & Runden 264 &  2135  \\
			\hline	
			Loop 5 & Runden 512 &  4119  \\
			\hline	
			Loop 6 & Runden 1024 &  8215  \\
			\hline	
			Loop 7 & Runden 2048 &  16407  \\
			\hline	
			Loop 8 & Runden 4096 &  32791  \\
			\hline	
			Loop 9 & Runden 8192 & 65559  \\
			\hline	
		\end{tabular}
		\label{theap1}
\end{table*}
\\Overhead Timer-Messung: $ 6 Zyklen $
\\Overhead Registerzuweisung: $ 19 - 6 = 13 Zyklen = 19 ns $
\\Messung der Registerzuweisung mit wmb()\footnote{wmb(These functions insert hardware memory barriers in the compiled instruction flow; their actual instantiation is platform dependent. An rmb (read memory barrier) guarantees that any reads appearing before the barrier are completed prior to the execution of any subsequent read. wmb guarantees ordering in write operations, and the mbinstruction guarantees both. Each of these functions is a superset of barrier). Das bedeutet, dass die Schreiboperationen auf die Hardware bis zu dieser Barriere abgeschlossen sein müssen und man davon ausgehen kann, dass der Hardwarezugriff bereits erfolgt ist. Somit kann man messen, wie lange ein Hardwarezugriff zum Beschreiben einer LED dauert und diese Zeit von der Gesamtzeit abziehen. Um ein sinnvolles Ergebnis zu erhalten, sollte auch die Messung mit wmb() arbeiten. } 

\subsection{Unterbrechung von Task durch ISR}
Ein Task läuft und speichert in einer While-Schleife immer die aktuelle Zeit. Er wird durch eine ISR unterbrochen. Sobald der Task wieder anläuft, wird wieder die Zeit gemessen. Die gesuchte Zeit ist die Different aus Start- und Endzeit.
 

\section{RT-Features}
	\begin{enumerate}
		\item Welche Unterschiede/Gemeinsamkeiten gibt es zwischen FreeRTOS und Linux?
		\item Prioritäten 
		\item Semaphore
		\begin{enumerate}
			\item Task1 setzt Timer und nimmt Semaphor $ \rightarrow $ Schlafen $ \rightarrow $ Task2 lässt Semaphor wieder los $ \rightarrow $ Timer stop
			\item Task 1 setzt Timer und nimmt Semaphor $ \rightarrow $ Task1 lässt Semaphor wieder los und Timer wird beendet
			\item Messen der Zeit, die benötigt wird, wenn ein Semaphor belegt ist und ein Task versucht, darauf zuzugreifen?
		\end{enumerate}		
		\item Message Passing (s. Semaphore)
		\item Queues (s. Semaphore)
		\item Flags (s. Semaphore)
		\item Posix-Features in Linux
	\end{enumerate}
	
	
\subsection{Task Switching}
Unter Task Switching versteht man die Zeit, die der Scheduler braucht, um von einem Task zu einem anderen zu wechseln. Dieser Wechsel wird nach der Scheduling-Strategie des Schedulers vollzogen, d.h. der Task wird nicht etwa durch einen Interrupt oder durch einen höher prioren Task unterbrochen.
\subsubsection{FreeRTOS}
\paragraph{Variante 1}
Es werden zwei Tasks \textit{Task1} und \textit{Task2} erzeugt. Diese Tasks haben einen Workload, der darin besteht, in einer For-Schleife eine Variable hoch zu zählen. Nach jedem Inkrementieren der Variable wird ein Context-Switch erzwungen (mit taskYIELD()). Wenn die Variable eine bestimmte Höhe erreicht hat, wird das Experiment beendet. Es wird dabei die Zeit gemessen, die zwischen dem Betreten des ersten Tasks und dem Verlassen des letzten Tasks vergeht. Ein Task-Switch trifft also zwei Mal so häufig auf, wie die Schleife durchgelaufen wird. 
\\\\Von der gemessenen Zeit muss noch der eigentliche Workload abgezogen werden. Dafür werden vor dem Starten der Tasks zwei For-Schleifen durchlaufen mit der gleichen Anzahl an Durchgängen wie in den Tasks.
\paragraph{Variante 2}
Es werden zwei Tasks erzeugt, in denen eine For-Schleife mit der Anzahl der Testdurchläufe ausgeführt wird. In der Schleife befindet sich in der Reihenfolge:
\begin{itemize}
	\item Starte Messung
	\item Erzwinge Task-Switch mit taskYield()
	\item Stoppe Messung
\end{itemize}
Der Vorteil an dieser Methode ist, dass es keinen Overhead gibt. Diese Messung ist also genauer. Von dem Ergebnis muss noch die Messzeit von sechs Zyklen abgezogen werden. Zu beachten ist, dass beide Tasks damit beginnen, die Startzeit der Messung zu speichern. Das führt dazu, dass die erste Startzeit überschrieben wird. Die letzte Startzeit ist dafür ungültig und darf nicht in dem Endergebnis berücksichtigt werden. 

\subsection{Preemption-Zeit}
Die Preemption-Zeit ist die Zeit, die benötigt wird, um einen Task-Switch zu vollziehen, wenn ein niederpriorer Task durch einen Interrupt oder durch einen höher priorisierten Task oder einen Interrupt unterbrochen wird. Das bedeutet, der Scheduler wird außerhalb des regulären Tick-Interrupts aufgerufen.
\subsubsection{FreeRTOS}
Ein niederpriorer Task verrichtet Arbeit. Dieser Task wird nach einer bestimmten Zeit von einem höher  priorisierten Task unterbrochen. Es gibt zwei Funktionen in FreeRTOS, um einen Delay herbeizuführen: \textit{vTaskDelay} und \textit{vTaskDelayUntil}. \textit{vTaskDelay} wacht nach einer bestimmten Anzahl von Ticks auf. Um die Zeit zu messen, kann die Startzeit in einer Endlosschleife im arbeitenden Task dauerhaft ausgelesen werden. Wenn der Task unterbrochen wird, wurde die aktuellste Zeit vorher gespeichert. Sobald der höher priorisierte Task aufgewacht ist, wird wieder die Zeit gemessen. Das \textit{vTaskDelayUntil} wird nur jeden Tick ausgeführt. 
\\\\Eine andere Möglichkeit, die Preemption Zeit zu messen, ist, dass ein hochpriorer Task sich selbst verabschiedet und hinterher von einem niederprioren Task aufgeweckt wird. Dieses führt direkt zu einem Context-Switch.
\\\\Noch eine Möglichkeit ist es, einen hoch priorisierten Task 1 zu suspendieren und dann einen niedriger priorisieren Task 2 laufen zu lassen. Während der Task 2 läuft, wird ein Interrupt ausgelöst, der Task 1 fortsetzt und somit einen Context-Switch erzeugt.
\subsubsection{Linux}

\subsection{Semaphor Shuffle Time}
Die Semaphor Shuffle Time ist die Zeit, die ein Task braucht, um an einem von einem anderen Task genommenem Semaphor aufzuwachen, wenn dieser wieder losgelassen wird. Dieser Versuch kann durchgeführt werden, indem ein Task einen Semaphor nimmt und danach ein Context-Switch durchgeführt wird.
	
\subsection{DLB Time}
Die Deadlock breaking time ist die Zeit, die benötigt wird, um einen potenziellen Deadlock durch Prioritätsinversion aufzulösen. Folgendes Beispiel verdeutlicht die Wichtigkeit der Prioritätsinversion:
Ein niederpriorer Task greift nach einem Mutex M. Dann wird er von einem mittelprioren Task unterbrochen. Dieser wiederum wird von einem hochprioren Task unterbrochen, welcher ebenfalls nach dem Mutex M greift und blockiert. Damit wird wieder Task 2 aufgerufen, welcher nun für immer Task 1 und damit auch den Mutex M blockiert, sodass der höher priorisierte Task niemals ausgeführt wird.
\\\\Mit der Prioritätsinversion bekommt Task 1 vorübergehend die Priorität von Task 3. Damit kann er nicht von Task 2 blockiert werden und nach getaner Arbeit den Mutex wieder freigeben. Damit kann der hoch priore Task seine Arbeit verrichten.

\subsubsection{FreeRTOS}
Es werden zwei Tasks erzeugt: Task 1 und Task 3. Task 3 ist der hochpriore Task und legt sich direkt schlafen. Task eins läuft in einer Schleife. Zuerst nimmt er sich den Mutex, dann startet er Task 2. Task 2 hat die mittlere Priorität und setzt Task 3 fort. Task 3 versucht nun nach dem Mutex zu greifen und wird blockiert. Da für Mutexe in FreeRTOS eine Prioritätsinversion stattfindet, wird wie erwartet Task 1 fortgesetzt und gibt den Mutex wieder frei. Es wird die Zeit gemessen, ab der Task 3 versucht, auf den Mutex zuzugreifen, bis der Mutex freigegeben und der Task deblockiert wird. 

\subsubsection{Linux}  	
 	
\section{Speicherzugriffe}
	\begin{enumerate}		
		\item Speicherplatzverbrauch des gesamten Systems
		\item MPU-Unterstützung
		\item In welchem Rahmen sind dynamische Speicherzugriffe möglich?
		\item Ggf. Zeitverbrauch bei Speicherallokation/-fragmentierung
			\begin{enumerate}		
				\item Allokation von z.B. 1000 Paketen und Messen der Zeit
				\item Vergleich von Context Switch mit Speicher Allokation und ohne (?)
				\item Vergleich von verschiedenen Methoden der Speicherallokation $ \rightarrow $ Was ist der Worst Case, der passieren kann?
			\end{enumerate}
	\end{enumerate}
	
\subsection{FreeRTOS}
Es gibt immer eine Mindestfrakturgröße. Außerdem sind die Funktionen Thread-Save, d.h. können durch keinen anderen Task unterbrochen werden. Ausnahmen davon bildet je nach Implementierung Fall 3.

\subsubsection{Heap\_1.c}
Blöcke werden allokiert, wenn genug Speicher da ist und nie wieder freigegeben.

\begin{table*}[htb]
	\centering
		\begin{tabular}{|l|p{11cm}|}
			\hline
			 Zugriffszeit & Konstant \\	
			\hline
			 Worst Case & Nicht mehr genügend Speicher vorhanden  \\
			\hline
			 Schlussfolgerung & Schnell, aber vorher überlegen, ob der Speicher für die Lebensdauer der Anwendung reicht. \\
			\hline
			 Testfall & Einfaches Allozieren, da kein Rechenaufwand durch Freigaben notwendig. \\
			\hline	
		\end{tabular}
		\label{theap1}
\end{table*}


\subsubsection{Heap\_2.c}
Es gibt eine minimale Blockgröße. Es gibt eine Liste, in der die Blöcke nach Größe sortiert sind. Es wird immer der nächst größte Block alloziert $ \rightarrow $Iteration durch Liste. Kein Verschmelzen von Blocks bei Freigabe. Zu große Blocks werden aufgeteilt. Der neu entstandene Block wird wieder in die Liste einsortiert. Nur sinnvoll, wenn der allozierte Speicher immer in etwa die gleiche Größe hat. 

\begin{table*}[htb]
	\centering
		\begin{tabular}{|l|p{11cm}|}
			\hline
			 Zugriffszeit & Am Anfang konstant, weil nur ein Block. Sobald die Liste mehrere Elemente besitzt, ist die Zugriffszeit linear abhängig von der Länge der Liste. \\	
			\hline
			 Worst Case & Nicht mehr genügend Speicher vorhanden oder es ist Speicher vorhanden, aber nicht mehr an einem Stück oder es gibt sehr viele kleine Segmente in der Liste und nur ein größeres ganz hinten  \\
			\hline
			 Schlussfolgerung & Durch Freigaben langsamer als in Fall eins. Nicht sinnvoll, wenn allozierte Blockgröße variiert.\\
			\hline
			 Testfall &  Allozieren von möglichst vielen minimal großen Blöcken und einem, der die doppelte Größe hat. Alle wieder freigeben $ \rightarrow $ Lange Liste mit vielen Einträgen $ \rightarrow $ Nochmal den größeren Block allozieren. Die Zeit für die Längste Freigabe kann auch gemessen werden. \\
			\hline	
		\end{tabular}
		\label{theap2}
\end{table*}

\subsubsection{Heap\_3.c}
Maskierte malloc und free Aufrufe des jeweiligen Compilers.

\begin{table*}[htb]
	\centering
		\begin{tabular}{|l|p{11cm}|}
			\hline
			 Zugriffszeit &  \\	
			\hline
			 Worst Case &  \\
			\hline
			 Schlussfolgerung & \\
			\hline
			 Testfall &  \\
			\hline	
		\end{tabular}
		\label{theap3}
\end{table*}

\subsubsection{Heap\_4.c}
Liste mit Blockzeigern und Blockgröße. Liste wird durchsucht, bis ein passendes Element gefunden wird. Bei Freigabe werden nebeneinander liegende Blöcke wieder zusammengeführt.

\begin{table*}[htb]
	\centering
		\begin{tabular}{|l|p{11cm}|}
			\hline
			 Zugriffszeit & Wie in Fall zwei, aber insgesamt schneller, da Blöcke bei der Freigabe wieder zusammengeführt werden und insgesamt tendenziell weniger Blöcke durchiteriert werden müssen.\\	
			\hline
			 Worst Case & Wie in Fall zwei\\
			\hline
			 Schlussfolgerung & Flexibelste Alternative, Freigabe ist geringfügig langsamer als in Fall zwei, weil Blöcke noch zusammengeführt werden.\\
			\hline
			 Testfall &  Allozieren wie in Fall zwei. Freigabe von jedem zweiten Block, sodass Speicher segmentiert bleibt. Dann nochmal den hintersten Block allozieren. \\
			\hline	
		\end{tabular}
		\label{theap4}
\end{table*}

\subsection{Verifizierung}
\begin{itemize}
	\item Unter welchen Voraussetzungen ist eine Verifizierung möglich?
	\item Verifizierung bei einem ganz bestimmten Szenario
\end{itemize}

\subsection{Multiprozessorunterstützung}