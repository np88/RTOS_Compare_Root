\chapter{Background on Operating Systems}\label{ch_background}

This chapter provides an deeper insight into the background of the topic. It gives details on \acp{RTOS} in general, on scheduling in FreeRTOS and LinuxRT, and the RT patch. 
Moreover, the causes of \ac{OS} jitter are described, especially the timer interrupt. 
Finally, the main design features of real-time programs are discussed and the benchmarking metrics for the two \ac{OS} are introduced. 
\par
\acp{OS} manage the hardware resources - \ac{CPU} time, \ac{I/O} and memory access  - for different tasks and process. 
Dependent on its level of functionalities, \acp{OS} have different levels of complexity.
While a system like FreeRTOS has a limited number of features, Linux offers a variety of services which run in the background. 

\section{The Scheduler}\label{s_scheduler}
Every task or process created by the kernel or a user, is managed by the operation system. 
The scheduler manages the tasks and decides whether a task switch is performed. 
The decision is based on the priority and the current state of the task. 

\subsection{Task States}\label{ss_task_states}
Dependent on events or resource availability, tasks can enter different states. 
In the following, the state flow used in FreeRTOS \cite{freertos} is described. 
The state flow in Linux is related, but extended by other states which are not of interest for the further work. 
\par
[Task state picture]

\paragraph{Ready}
When a task is schedulable, it is in the state \textit{Ready}. 
A process enters this state when it is first created, has been unblocked by an \ac{ISR} or an other task or when resources it was waiting for become available.

\paragraph{Running}
Tasks in this state get access to the \ac{CPU}, they are currently being executed.
This state can only be entered from tasks in the Ready state.

\paragraph{Blocked}
Tasks enter the \textit{Blocked} state when they are waiting on a queue or a semaphore or another event.
Tasks can switch from this state to the Ready state when the according event occurs, e.g. another tasks releases the semaphore.

\paragraph{Suspended}
A task can be suspended by itself or by another task. 
This task cannot wake up on an event but has to be explicitly unsuspended to reenter the Ready state.  

\subsection{Timer Tick}\label{ss_timer_tick}
The timer tick invokes the scheduler and can be programmed in FreeRTOS as well as in Linux.
The tick is triggered by a timer interrupt a definite number of times per second - usually 100 times. 
If the tick period is too low, tasks may finish running a long time before the next tick occurs.
Therefore, processor time might be wasted.
On the other hand, if the tick period is too high, the \ac{OS} overhead on the system is too large.  
The scheduling routine and an internal counter update are invoked in FreeRTOS in the timer \ac{ISR}.
Further, the timer tick causes latency in the system performance called \textit{OS jitter}.
 
[Picture for timer tick] 

\subsection{Scheduling Policies}\label{ss_scheduling_policy} 
The scheduler decides which task is allowed to enter the Ready state. 
The decision is based on the scheduling policy of the \ac{OS}.
There are mainly two different types of scheduling: \textit{Preemptive} and \textit{cooperative} scheduling.
In cooperative scheduling, tasks cannot be interrupted, they have to release the processor voluntarily. 
The scheduling policy is crucial for \acp{RTOS} because it determines the handling of real-time tasks.
Obviously, real-time tasks usually have the highest priority and should not be preempted by tasks with lower priority.

\subsubsection{Idle Task}
The \textit{Idle Task} is scheduled when no other tasks are present in the Ready queue because the processor is not allowed to run out of work.
It usually has the lowest possible priority.
This task is often used to put the \ac{CPU} in a low-power mode (scaling down frequency or executing the \textit{halt} instruction). 
Moreover, it can be used to perform background processes or as indicator for spare time  

\subsubsection{Scheduling in FreeRTOS}
Scheduling in FreeRTOS \cite{freertos} can be either cooperative or preemptive and is purely priority based.
The maximum priority can be defined by the user. 
The memory footprint grows with increasing priority number, so it is recommended to choose only as many priority levels as needed.
The task with the highest priority which is in the Ready state will be scheduled. 
Tasks can have the same priority if desired.
Priorities can be changed in runtime.
\par
All tasks are managed in doubly linked lists dependent on their state. 
The Ready state is implemented as a list array indexed by the priority level. 
When the scheduler is invoked, it first updated the Ready lists and then schedules the next task.
In case there are multiple tasks in one list, the \ac{RR} algorithm is used to pick the one.

[Picture Ready Queue] 
 
\subsubsection{Scheduling in Linux}\label{sss_scheduling_in_linux} 
Scheduling in Linux \cite{love:lkd} \cite{jones:itlcfss} is more complex than in FreeRTOS.
Three scheduling classes are used to determine which task will be selected: \textit{sched\_rt}, \textit{sched\_fair} and \textit{sched\_idletask}.
Sched\_rt implements the scheduling of real-time tasks and has the highest priority. 
General purpose tasks are using the sched\_fair class and the remaining class is used by the idle task.

\paragraph{sched\_rt} 
Linux real-time tasks are always scheduled prior to any other task. 
The default priority levels range from 0 to 99 where 99 is the highest possible value.
The maximum priority can be configured by the user. 
The run queue is implemented comparable to the one of FreeRTOS. 
In Linux, there are two different scheduling policies for real-time tasks: \ac{RR} (preemptive) and \ac{FIFO} (cooperative).

\paragraph{sched\_fair}
For the sake of completeness, the fair scheduling algorithm is briefly described in this section.
Linux was originally developed as a General Purpose \ac{OS}, so its scheduling algorithm is optimized to treat all tasks as fair as possible. 
The current scheduler is called \textit{\ac{CFS}} and was introduced in Linux kernel 2.6.23.
It is implemented as a Red-Black tree, which is self-balancing (no path is more than twice as long as any other).
An element of the tree can be accessed in in O(log n), where n is the total number of nodes in the tree.
\par
The prioritization of the \ac{CFS} is based on the time the tasks have already been executed. 
The lesser the time compared to the other task, the higher the chance to get \ac{CPU} access.
The most-left node is scheduled on a context switch.
Further, the priority of an element can be influenced using the \textit{nice} command. 
It puts a weight on the according node which will change the priority relative to the other nice values.

\section{Intertask Communication and Synchronization}\label{s_intertask_communication}
In \acp{OS} usually not only one but many different tasks are active.
These tasks need ways to communicate with each other.
Moreover, race conditions on critical resources, e.g. concurrent memory access, needs to be prohibited.
The mechanisms introduced in the following are available for FreeRTOS as well as for Linux.

\subsection{Events}
In many cases tasks need to wait until another task completes execution.
Instead of polling a resource (actively waiting and therefore wasting \ac{CPU} resources), tasks usually wait for an event to happen.
Therefore, a task blocks or sleeps on a specific signal.
When another task completes execution, it triggers the signal and wakes the task waiting on it.
Such a signal can also be triggered by an \ac{ISR}

\subsection{Memory access}
Concurrent memory access of multiple tasks can have undesired results as illustrated in the following example:\\
Person A and person B want to withdraw money (both 500 Euros) from a bank account via an ATM at the same time.
Task A starts processing the request of person A.
It reads the currently saved value X from memory and subtracts 500 Euros.
At this point it may run out of time and task B is scheduled.
Task B also reads the currently stored value X from memory (which has not yet been updated) and subtracts 500 Euros.
Like A before, task B is interrupted at this point and task A is scheduled.
A writes back the new value X and finishes execution.
Then, B also writes back its value X.
Obviously, the value of X - 500 Euros is wrong, it should be X - 1000 Euros. 
\par
To prevent such inconsistencies, the memory has to be locked by the task until the correct value has been written back.
So called \textit{mutexes} can be used for this purpose.
When a mutex (short for mutual exclusion) is taken by a task, every other task which tries to access this mutex will be blocked.
By releasing the mutex, the waiting tasks are unblocked.
Mutexes are a special form of semaphores.
Semaphores allow a definite number of tasks to access a particular resource, for a mutex it is only one.

\subsection{Message Passing}
Besides controlling the execution flow of other tasks using the mentioned features, tasks can also pass messages between each other to exchange information. 
Usually, one task blocks on a message queue until another task puts a message in this queue.
That event wakes up the blocking task and it retrieves the message.
This mechanism is a mix of signaling event and synchronizing shared memory access.

\section{Interrupt Handling}\label{s_interrupt_handling}
Interrupts signals provide an important method for the processor to communicate with peripheral devices.
The devices range from mice and keyboards to Ethernet or harddrive controllers.
The interrupt signal from the hardware device is connected to the interrupt controller of the processor. 
This controller signals the processor that an \ac{IRQ} has arrived.
Now, as the name suggests, the currently executing process is interrupted, the context saved and the corresponding \ac{ISR} is loaded to be executed.
Because they disturb the execution flow of other processes, \acp{ISR} should be kept as short as possible.
Typically, only urgent operations are performed in the \ac{ISR}. 
For less critical work, e.g. copying data into a transmit buffer of a network device, an extra task is started which can be scheduled later.
The minimal version of an \ac{ISR} should at least contain the acknowledge of the interrupt so the underlying hardware can continue its work.
The time between an interrupt being triggered and the first instruction of the corresponding \ac{ISR} is called interrupt latency.
\par
Interrupts can occur any time and are serviced immediately.
Consequently, any code currently running will be interrupted.
Some sections in the kernel code have to be run atomically to prevent critical errors in the systems.
Such sections are called critical sections.
Interrupts are usually disabled on entering a critical section.
Therefore, servicing the interrupt is postponed what causes a higher interrupt latency.
Interrupts can be prioritized what causes high priority interrupts to disturb the execution of lower prioritized interrupts.
This is called interrupt nesting.
 
\subsection{Interrupts in FreeRTOS}\label{ss_interrupts_in_freertos}
FreeRTOS itself contains only one interrupt: The timer tick (s. \ref{s_timer_tick}.
Other devices and interrupts may be installed on demand, but they are not handled by the OS. 
It is only in charge of task managing and inter-task communication.
For the application development, it means that an interrupt handler has to be written and registered in the \ac{GIC}.
As all interrupt handling is up to the programmer, it is easy to keep track of the number of interrupts in the system.

\subsection{Interrupts in Linux}\label{ss_interrupts_in_linux}
The interrupts in Linux are integrated into the operation system.
Each hardware device needs a driver to communicate with the \ac{OS}.
This driver provides \textit{open()}, \textit{read()} or \textit{write()} functions to access the device. 
It has to be registered before the device can be used.
Drivers can be started at boot time or dynamically be loaded as modules during runtime.
The interrupt handler is part of the driver and has to be registered in the kernel as well by calling the function \textit{irq\_request()} and on deregistration freed by calling \textit{irq\_free()}.
When an interrupt occurs, the \textit{do\_IRQ()} kernel function occurs which takes care of all \acp{ISR}. 

[Picture Linux Kernel development, p. 123]

\section{Delays}
Different delays caused by the underlying hardware or the \ac{OS} are crucial in real-time applications.
There are mainly three kind of delays:
\begin{enumerate}
	\item Delays from interrupts
	\item Delays from task execution and synchronization
	\item Delays from cache misses
\end{enumerate}
Moreover, the boot time can be crucial in special real-time application.
[note on uniprocessor systems]

\subsection{Delays from Interrupts}
The first kind of delays (for details refer to \ref{s_interrupt_handling}) can only be prevented by introducing critical sections. 
However, this may cause higher interrupt latencies and is counterproductive in applications which rely on a fast interrupt response time.
Critical sections are mainly found inside of the kernel. 
As interrupts are caused by \ac{I/O} devices, the delays from interrupts will increase when the system heavily communicates with a large number of peripherals. 

\subsection{Delays from Cache Misses}
The last cause of delays is caching.
On one hand, it increases the performance of an application significantly by reducing slow memory accesses. 
On the other hand, the cache can be used by every process on the system.
The pages used by the real-time application could be flushed from the cache which causes hardly predicable caches misses.
Yet, software and special drivers can influence the cache behavior if provided by the hardware architecture.
Those drivers are available in Linux and can be manually included in FreeRTOS.
They allow to lock specific cache pages for critical data or applications, but should be used carefully.
Excessive use of page locking eventually has a negative impact on the overall system behavior.

\subsection{Delays Task Execution and Synchronization}
The second source of delays lies in tasks which are currently executing. 
There are several sources of latencies:
\\The obvious one is the task switching time when a context switch occurs.
This is not avoidable and happens either when the timer tick occurs (refer to \ref{ss_timer_tickt}) or when a task blocks, finishes or voluntarily releases the \ac{CPU}.
Another latency related to scheduling is the preemption time.
This is the time which it takes the \ac{OS} to interrupt a low priority task and schedule a high priority task.
The interrupt can be caused by giving a semaphore, sending a message or waking up the task from an \ac{ISR}.
\par
Besides from scheduling, task synchronization causes latencies in a \ac{OS}.
This process causes latencies which are dependent on the implementation and therefore specific for every \ac{OS}.
Examples are semaphores, mutexes, message passing or signals. 
When a mutex is released, other tasks may be unblocked.
This means, that whenever this action happens, the \ac{OS} has to check whether tasks can be moved from the Blocked state to the Ready state.
Moreover, if a task with higher priority was woken up, the current task is preempted and a context switch takes place.
Dependent on the application and the right synchronization method, the overall latency in a system can be reduced.
\par
The delays described in this section are \ac{CPU} bound delays compared to delays caused by ac{I/O} interrupts.
 
\subsection{Boot Time}
The boot time can be a relevant factor if the system need to start up very fast.
When a car is started, the driver does not want to wait 15 seconds until the ignition runs.
Obviously, the boot time depends on the memory print of the operation system and on the medium from which the \ac{OS} is booted.
Another important factor is the initialization of hardware structures, e.g \ac{FPGA} designs.
Moreover, a file system may be needed for the \ac{OS} kernel to work properly which must be loaded besides the actual kernel. 
A boot loader is necessary to start an application or an \ac{OS}.
For simple programs or light-weight \ac{OS} like FreeRTOS usually an \ac{FSBL} is sufficient.
Optionally it can load an \ac{FPGA} design as well.
For more complex systems like Linux \cite{jones:itlbp}, the \ac{FSBL} is used to load a more sophisticated \ac{SSBL}.
Then the \ac{SSBL} loads the kernel and optionally the initial RAM disk image into memory.
After those steps, the kernel can be decompressed and finally boot.
While booting, it initializes the file system with the previously loaded image, initializes peripheral devices and finally starts the user space application. 
\par
Ways to optimize this process will be discussed later (refer to section \ref{}).

\section{Linux and RT Patch}
As Linux is a highly complex operation system, it should be discussed in detail more closely.
Especially the differences between standard Linux and LinuxRT \cite{rostedt:iotrtp} will be pointed out.
The Linux RT patch aims to make the Linux kernel more preemptive and therefore, significant changes in the kernel structure were made.
The most important ones are removing large critical sections, reducing interrupt latencies and implementing priority inheritance (refer to \ref{s_interrupt_handling} for more details).

\subsection{Spin Locks}
As discussed before, large critical sections reduce the responsibility of a system.
On single \ac{CPU} systems, it is enough to disable interrupts in a critical section, but in multicore systems, concurrent access from multiple \acp{CPU} must be prevented as well.
Therefore, so called spin locks were implemented. 
When a spin lock is acquired by one task, another task which tries to take the same spin lock starts spinning in a busy loop.
The purpose of this is to protect very short critical sections where a context switch takes more time than waiting for the other task to finish.
Yet, spin locks were also used to protect large sections in the kernel and caused big delays.
To solve this problem, spin locks were replaced by mutexes when possible which allow the preemption of critical sections.   

\subsection{Threaded Interrupts}
One other big factor to reduce latencies was the introduction of threaded interrupts in the RT patch.
Originally, interrupt service requests were handled completely in interrupt context.
This means that high priority tasks had to wait for low priority interrupts to complete, e.g. disk \ac{I/O}.
A solution to this is moving the work from the interrupt context to an interruptible thread.
Therefore, when an interrupt occurs, a working thread in started (or resumed) in the \ac{ISR}.
As default, those threads have a real-time priority (refer to \ref{sss_scheduling_in_linux}) of 50 in the current implementation.
This mechanism allows priority based regulation of the \ac{ISR} execution because priorities of real-time tasks can be changed dynamically. 
Moreover, the delay caused by interrupts decreases significantly for high-priority real-time tasks.
In case an \ac{IRQ} has to be serviced immediately, there is still the possibility to set the \textit{IRQ\_NODELAY} flag on initialization.
As a result, the \ac{ISR} will not be threaded but proceeded in the original way. 

\subsection{Priority Inheritance}\label{ss_priority_inheritance}
A problem which may occur while synchronizing memory access for tasks with different priorities, is starving a high priority task due to unbounded priority inversion.
This can happen in the following situation \cite{rostedt:iotrtp}:
Task A to C have different priorities, where A has the lowest and C has the highest.
Task A takes mutex M and then is preempted by task B.
Task C attempts to access M as well but blocks as it is already taken.
Now C is indirectly blocked by B an undefined amount of time, maybe forever.
\par
This situation can be resolved by priority inheritance.
With priority inheritance, task A gets a priority boost when C tries to access the semaphore.
Therefore, task B is preempted by A and A can leave the critical section.
As soon as A releases mutex M, the priority level is set back to normal.
Now C is woken up and can finish its work before B is scheduled again.

\section{Quantifying an Operation System}
