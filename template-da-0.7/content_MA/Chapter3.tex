\chapter{Results}\label{ch_results}
In this chapter, the results from the previously described experiments are presented.
Moreover, the indeterministic aspects of the are further investigated for both operation systems. 

\section{Boot Time}
This section mainly shows the possible decrease of the boot time in Linux as there was no need to further improve the start up time of FreeRTOS.

\subsection{Boot Time of FreeRTOS}
The boot time of FreeRTOS has been quantified by formula \ref{eq_t_boot_free}.
As mentioned before, there is no need to optimize the FreeRTOS boot time, so the final $ t_{boot}^{free} $ is 1,1 s.

\subsection{Boot Time of Linux}
The boot time in Linux $ t_{boot}^{linux} $ was 27 seconds when using the initial boot configuration from Xilinx (see \ref{ss_booting_in_linux}). 
The new custom configuration was applied step by step to see the effects on the system:
 
\begin{enumerate}
	\item By changing the file system from \ac{RAM} disk to \ac{UBIFS}, $t_{filesys}$ becomes part of $t_{osload}$ and decreases to ?? s
	\item By further moving the \ac{FPGA} configuration from the \ac{FSBL} to the file system, the total boot time decreases to ?? s 
	\item Finally, the booting is moved from \ac{SD} card to \ac{QSPI} what decreases the boot time to ?? s.
	\item Optionally, the \ac{UBIFS} can be mounted read-only. This further decreases the boot time by 2 seconds, because some start-up checks are skipped in this mode. 
\end{enumerate}

The result of this experiment is a boot time which was decreased by 72 \% in read-write mode and by 80 \% in read-only mode.

\section{Task Switching Results}\label{s_task_switching_results}
The results for task switching show the minimum overhead in a system with at least two tasks for the maximum priority. 
This value is also valid for systems with more real-time tasks of the same priority which use the round robin scheduling algorithm.
For task switching between different priority levels, the scheduling is dependent on the number of priority level.
In such cases, the complete list has to be searched from the beginning.
Therefore, the task switching time is slightly higher than for task switching within the same priority level.
\par
The measurements are presented in two different figures. 
The upper one always shows the time measured on the x axis and the number this time has occurred on the y axis. 
This curve gives a good overview over the statistic and deviation of the measurement.
The lower picture shows the latencies plotted over time. 
This curve shows time dependent events like the timer tick.  
%Further, this presentation of the results is not only valid for the task switching time but for all results presented in the following.

\subsection{Task Switching Results FreeRTOS} \label{ss_task_switching_results_freertos}
\begin{figure}[hbt]
	\begin{center}
		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/task_switching_debug_FreeRTOS_start_end}
	\end{center}
	\caption{Task switching result FreeRTOS} \label{fig_tast_switching_result_free}
\end{figure}
As the red color in figure \ref{fig_tast_switching_result_free} shows, the mean value for FreeRTOS task switching is 238 ns. 
The standard deviation for the test set is 3.8 ns (1.6 \%).
The peaks at the time of 0.1 and 0.2 us are showing the active timer tick. 
The probability to capture the timer tick in this experiment is very high because a large density of the test program code is included into the time measurement.
The maximum value measured for the tick is 1.059 us.
When the task switching time is subtracted from this value, the resulting tick overhead is 821 ns.
The reason for the different tick times (1.059 us and 0.752 us) cannot be clearly verified, as no proper tracing tools were available. 
Yet, some assumptions can be made on the behavior of the system. 
In table \ref{tab_task_switching}, the test algorithm is described. 
Depending on the point in time when the tick interrupts the code execution, the delay time can vary.
When the interrupt occurs before line 2 was executed, a task switch is performed and the time stop in line 3 is executed.
When the code continues to run, a yield is performed in line 5.
After the context switch, Task 1 continues in line 2 and another context switch is performed. 
So actually two context switches are measured. 
Another scenario which is theoretically possible is that the tick interrupts the test program right between line 3 and 4. 
In that case, the tick would not be visible in the graph.
Moreover, the delay can be caused by loading data needed by the \ac{ISR} to the cache.
\par
Further, small spike clusters which cause a jitter of about 35 ns are visible during the complete test.
Those cannot be explained by the test setup of the software, so it seems likely that they are caused by hardware, e.g. the cache mechanism.  
The delays observed in this experiments are also valid for the experiments in the following.
 
\subsection{Task Switching Results LinuxRT} 
The mean value for task switching in LinuxRT is 1.46 us and the standard deviation is 131 ns (9.0 \%).
The higher standard deviation is nicely visible in the upper plot of figure \ref{fig_tast_switching_result_linux}. 
Moreover, the timer tick is clearly recognizable every 10 ms.
Its maximum value is 18.945 us whereas the lower values are pending around 10 us.
Therefore, the maximum tick overhead is 17.485 us.
The reasons for the differences of the tick delay are the same as in FreeRTOS.
Further, LinuxRT executes softirqs after the tick interrupt.
Their number varies from tick to tick and therefore causes different delays. 
As in FreeRTOS, small spike clusters are visible during the complete test.
Because of the higher noise, they do not become as apparent as in the FreeRTOS measurement.

\begin{figure}[htb]
	\begin{center}
		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/task_switching_results_measurements_cfg6_int_saves}
	\end{center}
	\caption{Task switching result LinuxRT} \label{fig_tast_switching_result_linux}
\end{figure}

The mean task switching latency in LinuxRT is 6.1 times higher than in FreeRTOS.
This is mainly due to the implementation of the yield function in both systems.
Whereas the yield function in Linux causes a hierarchy of function calls, the yield in FreeRTOS is implemented as macro.   

\section{Semaphore Results}
This sections summarizes the results for the single mutex latency, the semaphore shuffling time and the event signaling. 
As the plots look very similar to section \ref{s_task_switching_results}, only the resulting values will be presented.
The single semaphore experiment shows the overhead arising when no other task interrupts an execution code secured by semaphores. 
The semaphore shuffling experiment defined by Kar quantifies the semaphore overhead when a second task tries to access data which is locked by a semaphore. 
The last experiment measures the latency which is caused by event synchronization. 
Concretely, this means waking up a task by signaling a binary semaphore in FreeRTOS or a condition variable in Linux.
\par
In time critical applications, the choice of the synchronization method can be crucial.
For example, sometimes the overhead of priority inheritance can be avoided by specific application design.

\subsection{Semaphore Results FreeRTOS}
All semaphore functions in FreeRTOS are based on message queues.
Mutexes support priority inheritance compared to the other kind of semaphores provided in FreeRTOS.
Therefore, the overhead when working with mutexes is slightly higher. 
The results of this measurement are presented in table \ref{tab_results_semaphores_freertos}. 

\begin{table}[htbp]
	\centering
		\begin{tabular}{|l||l|l|l|}
			\hline
				Test 											& Single 		& Shuffle 	& Binary 	\\
				\hline 
				Mean  										& 257 ns		& 1.912 us	& 846 ns	\\
			  \hline
			  Std. deviation (total)	  & 15.2 ns		& 31 ns			&	4ns			\\
			  \hline
			  Std. deviation (\%)  			& 5.9 \%		& 1.64 \%		&	0.47 \% \\ 
			  \hline
			  Max. tick delay	(total)		& 4.569 us	& 5.166 us	&	1.3 us  \\
				\hline
				Max. tick delay - mean		&						&						&					\\
			\hline
		\end{tabular}
	\caption{Results semaphore tests in FreeRTOS}
	\label{tab_results_semaphores_freertos}
\end{table}

As already mentioned, the causes of delays are summarized in section \ref{ss_task_switching_results_freertos}.

\subsection{Semaphore Results LinuxRT}
The Linux implementation of the tests uses the POSIX \ac{API}.
Comparing the mean values (see table \ref{tab_results_semaphores_linux}), the single semaphore test scores as well as the one in FreeRTOS.
Still, the standard deviation is much higher (46 \% compared to 5.9 \%).
The semaphore shuffling time in LinuxRT is 3.3 times higher than in FreeRTOS.
This is mainly caused by two context switches which are part of this experiment (see table \ref{tab_sem_kar}). 
They are caused by the blocking at the mutex of task 2 in line 4 and by the call yield function of task 1 in line 6.
The switch takes about 3 us and therefore almost half of the time. 
Even when considering the task switch time in the experiment, the latency in LinuxRT is still higher than in FreeRTOS.
The same problem arises for the event signaling experiment which contains one context switch.
Here, FreeRTOS is 3.01 times faster than Linux. 

\begin{table}[htbp]
	\centering
		\begin{tabular}{|l||l|l|l|}
			\hline
				Test 											& Single 		& Shuffle 	& Binary 	  \\
				\hline 
				Mean  										& 252 ns		& 6.342 us	& 2.554 us  \\
			  \hline
			  Std. deviation (total)	  & 116 ns		& 286 ns		&	181 ns	  \\
			  \hline 
			  Std. deviation (\%)  			& 46 \%			& 4.51 \%		&	7,09 \%   \\ 
			  \hline
			  Max. tick delay	(total)		& 29.144 us	& 27.084 us	&	13.629 us \\
				\hline
				Max. tick delay - mean		&	28.892 us	&	20.742 us	&	11.075 us	\\
			\hline
		\end{tabular}
	\caption{Results semaphore tests in LinuxRT}
	\label{tab_results_semaphores_linux}
\end{table}

\section{Message Passing Time}
Message passing is another mechanism of task synchronization, so it is relevant to consider its performance.
The algorithm (see table \ref{tab_message_passing}) also provides some points where a task switch can cause faulty results.
One possible error is that the execution is interrupt between line 2 and 3.
This causes one task switching delay because task 2 is not schedulable, so task 1 will be rescheduled.
Another error can happen when task 2 is interrupted before blocking on the queue. 
This causes the message to be already available in the queue after task 1 yields the processor. 
Therefore, task 2 does not block but retrieves the message immediately what takes less time than the original procedure.

\subsection{Message Passing in FreeRTOS}
\begin{figure}[htb]
	\begin{center}
		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/message_passing_latency_FreeRTOS_start_end}
	\end{center}
	\caption{Binary semaphore result FreeRTOS} \label{fig_message_passing_free}
\end{figure}
The mean time for passing one message with the content of one byte is 901 ns. 
The standard deviation is 24.9 ns (2.76 \%) and the maximum peak occuring while the timer interrupt is active is 2.531 us.
This makes a total overhead of 1,63 us. 
The plot (figure \ref{fig_message_passing_free}) clearly shows the error cases discussed above.  

\subsection{Message Passing in LinuxRT}
\begin{figure}[htb]
	\begin{center}
		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/message_passing_latency_measurements_cfg6_int_saves}
	\end{center}
	\caption{Condition variable result LinuxRT} \label{fig_message_passing_linux}
\end{figure}

As already mentioned, the SysV \ac{API} was used for this experiment, not the POSIX \ac{API} as it is not supported by the used platform.
The mean time for passing one message in LinuxRT with the content of one byte is 5.135 us (see figure \ref{fig_message_passing_linux}). 
The standard deviation is 268 ns (5.22 \%) and the maximum peak occuring while the timer interrupt is active is 18.657 us.
This makes a total overhead of 13.522 us. 
The mean message passing latency in FreeRTOS is 5.7 times faster than in LinuxRT.

\section{Deadlock Breaking Time}
The detailed algorithm to obtain the deadlock breaking time is described in table \ref{tab_deadlock}.
This time gives an orientation on the time the operation system needs to resolve a priority inversion by the implemented priority inheritance algorithm.
As usually the task with the highest possible priority is running in this experiment, the timer tick only causes an unnecessary context switch which results in the same task being continued.
This experiment has similarities to the semaphore shuffling but also includes the priority inheritence component.

\subsection{Deadlock Breaking Time in FreeRTOS}
\begin{figure}[htb]
	\begin{center}
		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/deadlock_results_FreeRTOS_start_end}
	\end{center}
	\caption{Deadlock breaking time FreeRTOS} \label{fig_deadlock_result_free}
\end{figure}
The mean time for the deadlock breaking time in FreeRTOS is 2.113 us. 
The standard deviation is 34.5 ns (1.63 \%) and the maximum peak occuring while the timer interrupt is active is 3.854 us.
This makes a total overhead of 1,74 us. 

\subsection{Deadlock Breaking Time in LinuxRT}
\begin{figure}[htb]
	\begin{center}
		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/deadlock_results_measurements_cfg6_int_saves}
	\end{center}
	\caption{Deadlock breaking time LinuxRT} \label{fig_deadlock_result_linux}
\end{figure}
The mean time for the deadlock breaking time in FreeRTOS is 20.68 us. 
The standard deviation is 643 ns (3.11 \%) and the maximum peak occuring while the timer interrupt is active is 37.146 us.
This makes a total overhead of 16.466 us.
The LinuxRT implementation is 9.79 times slower than the same implementation in FreeRTOS.
 
\section{Interrupt Latency} 

\section{Preemption Time}
\begin{figure}[htb]
	\begin{center}
		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/preemption_time_FreeRTOS_start_end}
	\end{center}
	\caption{Preemption result FreeRTOS} \label{fig_preemption_result_free}
\end{figure}

\begin{figure}[htb]
	\begin{center}
		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/preemption_time_measurements_cfg6_int_saves}
	\end{center}
	\caption{Preemption result LinuxRT} \label{fig_preemption_result_linux}
\end{figure}


%\subsection{Single Mutex Results}

%\begin{figure}[htb]
%	\begin{center}
%		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/mutex_single_FreeRTOS_start_end}
%	\end{center}
%	\caption{Mutex in single task result FreeRTOS} \label{fig_mutex_single_result_free}
%\end{figure}

%\begin{figure}[htb]
%	\begin{center}
%		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/mutex_single_measurements_cfg6_int_saves}
%	\end{center}
%	\caption{Mutex in single task result LinuxRT} \label{fig_mutex_single_result_linux}
%\end{figure}

%\subsection{Semaphore Shuffling}
%\begin{figure}[htb]
%	\begin{center}
%		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/mutex_shuffle_FreeRTOS_start_end}
%	\end{center}
%	\caption{Mutex shuffling result FreeRTOS} \label{fig_mutex_shuffle_result_free}
%\end{figure}

%\begin{figure}[htb]
%	\begin{center}
%		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/mutex_shuffle_measurements_cfg6_int_saves}
%	\end{center}
%	\caption{Mutex shuffling result LinuxRT} \label{fig_mutex_shuffle_result_linux}
%\end{figure}

%\subsection{Event Signaling}

%\begin{figure}[htb]
%	\begin{center}
%		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/bin_semaphore_FreeRTOS_start_end}
%	\end{center}
%	\caption{Binary semaphore result FreeRTOS} \label{fig_bin_sem_result_free}
%\end{figure}

%\begin{figure}[htb]
%	\begin{center}
%		\includegraphics[trim=2.5cm 1.5cm 2.5cm 1.5cm, scale=0.7] 			{inputs/pictures_ch3/cond_var_results_measurements_cfg6_int_saves}
%	\end{center}
%	\caption{Condition variable result LinuxRT} \label{fig_cond_var_result_linux}
%\end{figure}