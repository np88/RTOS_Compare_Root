\chapter{Introduction}
It is hard to imagine that the history of modern digital computers began in the early 19th century \cite{tanenbaum:mos}.
The English mathematician Charles Babbage (1792-1871) designed his \textit{analytical engine} which was purely mechanical. 
He never got it working though because it was not possible to produce the high precision components that he needed.  Obviously, he did not need an operating system for his analytical machine.
During some of his work, he cooperated with Ada Lovelace who wrote an algorithm for this machine to calculate Bernoulli numbers in 1843 \cite{toole:ateon} and therefore is considered the first programmer.
\par
Not until 100 years later, Zuse, von Neumann and others succeeded to build calculating engines. 
Those machines were made of relays and later vacuum tubes, the programming was realized via plugboards and then punched cards.
Still, there was no operating system.
The next computer generation arose with the development of the transistor in the mid-1950s.
For the first time, a program was written down in FORTRAN or assembler, then punched in cards and processed by a computer, all developed by IBM. 
To optimize the process, multiple jobs were recorded on a tape and processed together by the ``ancestor of today's operating system'' \cite{tanenbaum:mos} which was developed concurrently.
With the introduction of \acp{IC}, IBM developed its 360 series.
This series ranged from less powerful and cheaper machines to more powerful and expensive ones.
New was the idea to use the same architecture and instruction set on all machines, what means that the \ac{OS} can run on all machines as well.
Further, the time sharing principle for multiple users was invented later on.
This and the boom of minicomputers influenced the development of the UNIX operating system.
From the early eighties and the introduction of \ac{LSI} circuits, the development of the personal computer dominated and \textit{General Purpose \acp{OS}} like \ac{DOS} and later MicroSoft Windows, Apple's \ac{MAC} and Linux became popular until today. 

\section{Why Operating Systems?}
An operating system is a software program which provides access to the underlying hardware. 
Its purpose is to manage hardware resources - for example \ac{CPU} time, memory or \ac{I/O} access - as well as system and user processes efficiently. 
The \ac{OS} decides, when a process is allowed to run and access the resources.
Further, \acp{OS} provide synchronization features for task management, for instance semaphores or message passing.
Many \acp{OS} also inherit a set of drivers for different hardware platforms.
This shortens the development process of a new product and therefore the time-to-market.
Depending on the application there are different kinds of \acp{OS}. 
In General Purpose \acp{OS} the main goal is to maintain fairness between different users or processes. 
Consequently, every user or process should get an equal time slice of the available \ac{CPU} time or other shared resources like \ac{RAM}. 
\acp{OS} are also used in embedded systems. 
In contrast to General Purpose \acp{OS}, operation systems for embedded devices often have to run under special conditions, e.g. limited memory size or low power consumption. 
Some examples are embedded Linux, FreeRTOS or $\mu$COS.

\subsection{Real-Time Systems}
A special kind of embedded systems are \acp{RTOS} which are designed to meet specific deadlines. 
The main property of an \ac{RTOS} is determinism (and not necessarily high-speed performance).  
Further, real-time does not mean that the system is safety critical as this usually implies more safety arrangements, for instance redundancy.
Real-time systems are commonly divided into two classes \cite{stromblad:elfrtoemd}, depending of the consequence caused by missing a deadline:
\begin{itemize}
	\item Hard
	%\item Firm
	\item Soft
\end{itemize}
In hard real-time systems, missing a deadline causes system failure and is not tolerable.  
An example is the engine control system of a car which can be damaged or cause an accident because of delayed signals.
Another example is the release of an airbag in a car. 
It has to be triggered immediately when a crash happens, any delay could cause the loss of lives. 
More applications can be found in medical systems or industry processing control.  
%In firm real-time systems, deadline misses may occur at rare intervals and cause loss of \ac{QoS}, but not a complete system failure.
In soft real-time systems, deadlines can be missed but decrease the \ac{QoS}. 
These kind of systems are usually used for application with a continuous data flow like multimedia streaming applications or on-line reservation systems.
Missing of one data packet in these application may cause noise in a video conference but no lives would be harmed.

\subsection{How to choose the right OS?}
The class of a system always depends on its application. To meet the given requirements,
the underlying hardware and - often - an OS have to be chosen appropriately. 
Assuming that the hardware is capable of running more than a light-weight OS, the choice of the operating
system always depends on the real-time requirements of the system. 
Systems which have to provide hard real-time usually must be verified and certified. 
Verification means that each state of the system must be well defined and every change of input leads to a
determined state as well.
Soft real-time does usually not require that kind of verification, but the timings should be reliable. 
In embedded systems, Linux is widely used because it is free of charge, has a large community and therefore a high level of support. 
Moreover, it is comfortable to use as it embeds features like a command terminal, flexible module integration and a large number of available hardware drivers.
Yet, resulting from its structure and complexity, the downside of mainline Linux is still the lack of real-time capability.
\par
To achieve hard real-time performance, usually special \acp{OS} are used. 
Those can be based on a real-time kernel design or light-weight \acp{OS} like for example \textit{$\mu$COS} \cite{micrium:microcos} or \textit{FreeRTOS} \cite{freertos}.
They have very small memory footprint, fast boot time and no background services (deamons) which could unexpectedly disturb the execution of real-time tasks. 
Therefore the execution time of tasks and interrupt processing is highly predictable.
The jitter (variance of execution time) is very low compared to a general purpose \ac{OS}.
Yet, those systems have multiple disadvantages:
In light-weight \acp{OS}, every change in the underlying hardware requires a reconfiguration of the OS.
Furthermore, a high-level communication (e.g. terminal) with the system is not provided and has to be implemented if needed. 
Another solution is one of the hard real-time extensions for Linux like \textit{\ac{RTAI}} (based on a micro kernel) \cite{rtai} or \textit{Xenomai} (real-time development framework) \cite{xenomai}.
Further, companies like ENEA \cite{stromblad:elfrtoemd} make an effort to improve the real-time performance of their proprietary ENEA Linux.  
A hard real-time \ac{OS} is PikeOS \cite{sysgo:prt} which was developed by \textit{SYSGO Embedded Systems} and is not related to Linux.

\subsubsection{The preferred RTOS}
Obviously, the operating systems described above are not the optimum choice for developers. 
But what is actually the optimum with time considered the most valuable resource?
A system which provides all necessary drivers, requires as low configuration and modification as possible and can guarantee the right level of real-time capability. 
Further, it should be free of charge and have a high level of support.
This sounds rather impossible. 
All of the systems are either proprietary and therefore not free of charge for development, light-weight systems which do not provide any drivers or  


Consequently, an \ac{OS} which can provide deterministic timing as well as the convenience of a more advanced system is desirable.  
To make the right choice regarding an \ac{OS}, it is necessary to know how exactly the given systems differ in performance. 
Obviously, a Linux-based system will have higher latencies and jitter. 
Still, recently especially the Linux PREEMT\_RT patch (further: \textit{LinuxRT}) was improved a lot in the matter of predictability and is easy to apply to an existing Linux distribution. 
Whenever possible, it would be chosen over a light-weight system by a developer. 
To make this possible, some guidelines in the actual performance of the \acp{OS} are desirable. 
How does LinuxRT perform compared to a light-weight \ac{OS}?
When can LinuxRT be used and when is it inevitable to use a light-weight \ac{OS}?
To answer these questions, LinuxRT has to be compared to a suitable light-weight \ac{OS}. 
In the past decade, FreeRTOS has grown to be a popular \ac{RTOS} solution.
It is supported on many platforms, is freely available and already used in different market sectors, for example toys, aircraft navigation or engine control. 
Therefore, it is a good candidate to be used as reference.  
The next point to consider is how \acp{OS} can be compared to each other.
 
\subsection{Benchmarking of RTOS}
There are quite many criteria which can be applied to benchmark \acp{OS}.
For \ac{RTOS}, obviously, it is most important to consider features typically used in real-time applications.
Those are mainly task synchronization features, e.g. semaphores, message queues or signals.
Moreover, interrupt latency is crucial because interrupts usually wake up important tasks in \ac{RTOS}.
Another typical application is the periodic invocation of tasks. 
As these tasks have to be scheduled as precisely as possible, the jitter is an interesting metric.
More key features are preemption time of tasks and deadlock breaking time.
These two metrics indicate the capability of the system to interrupt a low priority task by a task with higher priority. 
Boot time can also be important in real-time systems as it is not acceptable to wait 15 seconds for the engine to run after starting the car.
Further, some systems support memory access supervision by a \ac{MMU}.
As \ac{RTOS} are usually used on embedded devices, the memory footprint is also of large interest. 
\par
One challenge is to choose the right criteria from the ones mentioned above. 
Another one is to measure values which are as accurate and comparable as possible.
Therefore, a way of time measurement has to be found, which can be applied on both systems with the least possible interference on the system.

\section{Related work}
Performance evaluation has already been done on different platforms and with different \acp{OS}. 
The first attempt to developing a real-time benchmark was by Kar and Porter in 1989 by introducing the \textit{Rhealstone Benchmark} \cite{kar:itrb} \cite{kar:artbp}. 
This benchmark is based on six parameters (for details refer to \ref{ss_rhealstone_benchmark_for_deterministic_application_latency}) the resulting value is calculated from.
The Rhealstone Performance Number is a weighted mean of all parameters. They implemented the benchmark under iRMX.
\par
Another and more recent comparison of operating systems was performed for a set of \ac{OS} suitable for small microcontrollers in 2009 \cite{Anh:sapeortosfsm}. 
In this paper, several \ac{RTOS} are introduced, but only four of them are chosen to be investigated in detail.
The choice is based on available support, documentation, scheduling type and more. 
For the \acp{RTOS}, algorithms on how to compare task switching, message passing, semaphore passing and memory allocation are presented.  
In \cite{gokhan:cstamfcoxamom}, memory footprint and context switching is compared between $\mu$COS and XilKernel\footnote{XilKernel \cite{xilinx:xilkernel} is an \ac{RTOS} developed by Xilinx.} on the softcore processor Microblaze.
Three different \acp{OS} - Xenomai, LinuxRT and eCos \cite{ecos} - are compared in \cite{Marieska:opokbaertosbaa}.
The performance metrics are similar to the Rhealstone benchmark.
Depending on the application, eCos and LinuxRT perform better than Xenomai.
The authors of \cite{cereia:peoaemulatrp} and \cite{betz:eeotlrpfrta} evaluate the real-time performance of LinuxRT compared to standard Linux.
In both works, a sample program is run solely, with CPU and I/O load. 
Whereas in \cite{cereia:peoaemulatrp} the focus is mainly on the effect of real-time priorities, in \cite{betz:eeotlrpfrta} different period lengths and multi-processor effects are also investigated. 
The results show a significant reduction in jitter when using LinuxRT.
\par
[Related work on OS jitter]

\section{Contribution}
In this work, a guideline on the choice of an operation system for specific use cases is presented.
Therefore, a set of benchmarks is defined based on the Rhealstone benchmark proposed by Kar and Porter \cite{kar:itrb} \cite{kar:artbp}. 
These benchmark metrics are extended by the boot time and task periodicity jitter which are crucial for many applications.
A detailed instruction on how to implement the benchmark is provided.
Further, a model is introduced on how to calculate OS latency from the obtained benchmark metrics. 
A special focus is put on the operation systems LinuxRT and FreeRTOS. 
FreeRTOS is the most important light-weight \ac{RTOS} nowadays.
As there is a large interest in using more comfortable \ac{OS} like Linux, the goal is to clearly define the limits of LinuxRT.
Moreover, the sources of OS jitter shall be detected and reduced as far as possible. 
The optimum result is a LinuxRT configuration with comparable benchmark results as FreeRTOS. 

\par
The remainder of the work is organized as follows. In chapter \ref{ch_background}, a detailed background on the topic is provided. 
Chapter \ref{ch_measurements} describes the performed measurements in detail. 
Further, in chapter \ref{ch_results} the results of the measurements are presented. 
In the last chapter \ref{ch_conclusion} the contribution of this work is summarized.